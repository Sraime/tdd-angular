import { EventEmitter } from '@angular/core';
import { AbstractType, Type } from '../common';
import { MockedDebugElement, MockedDebugNode } from '../mock-render';
import { MockedFunction } from '../mock-service';
export declare const MockHelper: {
    find<T>(debugElement: MockedDebugElement, component: Type<T>): null | MockedDebugElement<T>;
    find<T>(debugElement: MockedDebugElement, component: AbstractType<T>): null | MockedDebugElement<T>;
    find<T = any>(debugElement: MockedDebugElement, cssSelector: string): null | MockedDebugElement<T>;
    findAll<T>(debugElement: MockedDebugElement, component: Type<T>): Array<MockedDebugElement<T>>;
    findAll<T>(debugElement: MockedDebugElement, component: AbstractType<T>): Array<MockedDebugElement<T>>;
    findAll<T = any>(debugElement: MockedDebugElement, cssSelector: string): Array<MockedDebugElement<T>>;
    findDirective<T>(debugNode: MockedDebugNode, directive: Type<T>): undefined | T;
    findDirective<T>(debugNode: MockedDebugNode, directive: AbstractType<T>): undefined | T;
    findDirectiveOrFail<T>(debugNode: MockedDebugNode, directive: Type<T>): T;
    findDirectiveOrFail<T>(debugNode: MockedDebugNode, directive: AbstractType<T>): T;
    findDirectives<T>(debugNode: MockedDebugNode, directive: Type<T>): T[];
    findDirectives<T>(debugNode: MockedDebugNode, directive: AbstractType<T>): T[];
    findOrFail<T>(debugElement: MockedDebugElement, component: Type<T>): MockedDebugElement<T>;
    findOrFail<T>(debugElement: MockedDebugElement, component: AbstractType<T>): MockedDebugElement<T>;
    findOrFail<T = any>(debugElement: MockedDebugElement, cssSelector: string): MockedDebugElement<T>;
    getDirective<T>(debugNode: MockedDebugNode, directive: Type<T>): undefined | T;
    getDirective<T>(debugNode: MockedDebugNode, directive: AbstractType<T>): undefined | T;
    getDirectiveOrFail<T>(debugNode: MockedDebugNode, directive: Type<T>): T;
    getDirectiveOrFail<T>(debugNode: MockedDebugNode, directive: AbstractType<T>): T;
    getInput<T = any>(debugNode: MockedDebugNode, input: string): undefined | T;
    getInputOrFail<T = any>(debugNode: MockedDebugNode, input: string): T;
    getOutput<T = any>(debugNode: MockedDebugNode, output: string): undefined | EventEmitter<T>;
    getOutputOrFail<T = any>(debugNode: MockedDebugNode, output: string): EventEmitter<T>;
    mockService<I extends object, O extends object>(instance: I, overrides: O): I & O;
    mockService<T = MockedFunction>(instance: any, name: string, style?: 'get' | 'set'): T;
};
export declare const ngMocks: {
    find<T>(debugElement: MockedDebugElement, component: Type<T>): MockedDebugElement<T>;
    find<T, D>(debugElement: MockedDebugElement, component: Type<T>, notFoundValue: D): D | MockedDebugElement<T>;
    find<T = any>(debugElement: MockedDebugElement, cssSelector: string): MockedDebugElement<T>;
    find<T = any, D = undefined>(debugElement: MockedDebugElement, cssSelector: string, notFoundValue: D): D | MockedDebugElement<T>;
    findAll<T>(debugElement: MockedDebugElement, component: Type<T>): Array<MockedDebugElement<T>>;
    findAll<T = any>(debugElement: MockedDebugElement, cssSelector: string): Array<MockedDebugElement<T>>;
    findInstance<T>(debugNode: MockedDebugNode, instanceClass: Type<T>): T;
    findInstance<T, D>(debugNode: MockedDebugNode, instanceClass: Type<T>, notFoundValue: D): D | T;
    findInstances<T>(debugNode: MockedDebugNode, instanceClass: Type<T>): T[];
    flushTestBed(): void;
    get<T>(debugNode: MockedDebugNode, directive: Type<T>): T;
    get<T, D>(debugNode: MockedDebugNode, directive: Type<T>, notFoundValue: D): D | T;
    input<T = any>(debugNode: MockedDebugNode, input: string): T;
    input<T = any, D = undefined>(debugNode: MockedDebugNode, input: string, notFoundValue: D): D | T;
    output<T = any>(debugNode: MockedDebugNode, output: string): EventEmitter<T>;
    output<T = any, D = undefined>(debugNode: MockedDebugNode, output: string, notFoundValue: D): D | EventEmitter<T>;
    stub<T = MockedFunction>(instance: any, name: string, style?: 'get' | 'set'): T;
    stub<I extends object, O extends object>(instance: I, overrides: O): I & O;
};
