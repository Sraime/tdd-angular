"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSourceOfMock = exports.getMockedNgDefOf = exports.isMockOf = exports.isNgModuleDefWithProviders = exports.isNgInjectionToken = exports.isMockedNgDefOf = exports.isNgDef = exports.isNgType = exports.mapEntries = exports.mapValues = exports.mapKeys = exports.flatten = exports.getNgMocksFromTestBed = exports.NG_MOCKS = void 0;
var core_1 = require("@angular/core");
var testing_1 = require("@angular/core/testing");
var ng_mocks_universe_1 = require("./ng-mocks-universe");
var reflect_1 = require("./reflect");
exports.NG_MOCKS = new core_1.InjectionToken('NG_MOCKS');
exports.getNgMocksFromTestBed = function () {
    var testBed = testing_1.getTestBed();
    try {
        return testBed.inject ? testBed.inject(exports.NG_MOCKS) : testBed.get(exports.NG_MOCKS);
    }
    catch (e) {
        return undefined;
    }
};
exports.flatten = function (values, result) {
    if (result === void 0) { result = []; }
    if (Array.isArray(values)) {
        values.forEach(function (value) { return exports.flatten(value, result); });
    }
    else {
        result.push(values);
    }
    return result;
};
exports.mapKeys = function (set) {
    var result = [];
    set.forEach(function (_, value) { return result.push(value); });
    return result;
};
exports.mapValues = function (set) {
    var result = [];
    set.forEach(function (value) { return result.push(value); });
    return result;
};
exports.mapEntries = function (set) {
    var result = [];
    set.forEach(function (value, key) { return result.push([key, value]); });
    return result;
};
exports.isNgType = function (object, type) {
    return reflect_1.jitReflector.annotations(object).some(function (annotation) { return annotation.ngMetadataName === type; });
};
function isNgDef(object, ngType) {
    if (ngType === 'm') {
        return exports.isNgType(object, 'NgModule');
    }
    if (ngType === 'c') {
        return exports.isNgType(object, 'Component');
    }
    if (ngType === 'd') {
        return exports.isNgType(object, 'Directive');
    }
    if (ngType === 'p') {
        return exports.isNgType(object, 'Pipe');
    }
    return false;
}
exports.isNgDef = isNgDef;
function isMockedNgDefOf(object, type, ngType) {
    return typeof object === 'function' && object.mockOf === type && (ngType ? isNgDef(object, ngType) : true);
}
exports.isMockedNgDefOf = isMockedNgDefOf;
exports.isNgInjectionToken = function (object) {
    return typeof object === 'object' && object.ngMetadataName === 'InjectionToken';
};
exports.isNgModuleDefWithProviders = function (object) {
    return object.ngModule !== undefined && isNgDef(object.ngModule, 'm');
};
function isMockOf(object, type, ngType) {
    return (typeof object === 'object' &&
        (ngType ? isMockedNgDefOf(object.constructor, type, ngType) : isMockedNgDefOf(object.constructor, type)));
}
exports.isMockOf = isMockOf;
function getMockedNgDefOf(type, ngType) {
    var source = type.mockOf ? type.mockOf : type;
    var mocks = exports.getNgMocksFromTestBed();
    var mock;
    if (mocks && mocks.has(source)) {
        mock = mocks.get(source);
    }
    else if (mocks) {
        throw new Error("There is no mock for " + source.name);
    }
    if (!mock && source !== type) {
        mock = type;
    }
    else if (!mock && ng_mocks_universe_1.ngMocksUniverse.cache.has(source)) {
        mock = ng_mocks_universe_1.ngMocksUniverse.cache.get(source);
    }
    if (!ngType) {
        return mock;
    }
    if (ngType && isMockedNgDefOf(mock, type, ngType)) {
        return mock;
    }
    throw new Error("There is no mock for " + source.name);
}
exports.getMockedNgDefOf = getMockedNgDefOf;
function getSourceOfMock(type) {
    return typeof type === 'function' && type.mockOf ? type.mockOf : type;
}
exports.getSourceOfMock = getSourceOfMock;
//# sourceMappingURL=lib.js.map